In some cases, you need to extract information from a webpage that a simple CSS/XPath schema cannot easily parse. Or you want -driven insights, classification, or summarization. For these scenarios, Crawl4AI provides an that:
  1. Works with large language model supported by (Ollama, OpenAI, Claude, and more). 
  2. Automatically splits content into chunks (if desired) to handle token limits, then combines results. 
  3. Lets you define a (like a Pydantic model) or a simpler “block” extraction approach.


: LLM-based extraction can be slower and costlier than schema-based approaches. If your page data is highly structured, consider using or first. But if you need AI to interpret or reorganize content, read on!
## 1. Why Use an LLM?
  * : If the site’s data is unstructured, scattered, or full of natural language context. 
  * : Summaries, knowledge graphs, or relational data that require comprehension. 
  * : You can pass instructions to the model to do more advanced transformations or classification.


Crawl4AI uses a “provider string” (e.g., , , ) to identify your LLM. model that LightLLM supports is fair game. You just provide:
  * : If needed (for OpenAI, HuggingFace, etc.); local models or Ollama might not require it. 
  * (optional): If your provider has a custom endpoint. 


This means you into a single LLM vendor. Switch or experiment easily.
## 3. How LLM Extraction Works
1. (optional): The HTML or markdown is split into smaller segments if it’s very long (based on , overlap, etc.). 2. : For each chunk, the library forms a prompt that includes your (and possibly schema or examples). 3. : Each chunk is sent to the model in parallel or sequentially (depending on your concurrency). 4. : The results from each chunk are merged and parsed into JSON.
  * : The model tries to return JSON conforming to your Pydantic-based schema. 
  * : The model returns freeform text, or smaller JSON structures, which the library collects. 


For structured data, is recommended. You provide .
Below is an overview of important LLM extraction parameters. All are typically set inside . You then put that strategy in your .
1. (str): e.g., , . 2. (str): The API key or token for that model. May not be needed for local models. 3. (dict): A JSON schema describing the fields you want. Usually generated by . 4. (str): or . 5. (str): Prompt text telling the LLM what you want extracted. E.g., “Extract these fields as a JSON array.” 6. (int): Maximum tokens per chunk. If your content is huge, you can break it up for the LLM. 7. (float): Overlap ratio between adjacent chunks. E.g., means 10% of each chunk is repeated to preserve context continuity. 8. (bool): Set to chunk automatically. If you want a single pass, set . 9. (str): Determines crawler result is passed to the LLM. Options include: - : The raw markdown (default). - : The filtered “fit” markdown if you used a content filter. - : The cleaned or raw HTML. 10. (dict): Additional LLM parameters like , , , etc. 11. : A method you can call to print out usage info (token usage per chunk, total cost if known). 
```
extraction_strategy  LLMExtractionStrategy
  provider,
  api_token,
  MyModel.model_json_schema,
  extraction_type,
  instruction"Extract a list of items from the text with 'name' and 'price' fields.",
  chunk_token_threshold,
  overlap_rate,
  apply_chunking,
  input_format,
  extra_args ,  ,
  verbose


```

: In Crawl4AI, all strategy definitions should go inside the , not directly as a param in . Here’s a full example:
```
 os
 asyncio
 json
 pydantic  BaseModel, Field
 typing  
 crawl4ai  AsyncWebCrawler, BrowserConfig, CrawlerRunConfig, CacheMode
 crawl4ai.extraction_strategy  LLMExtractionStrategy
 ():
  name: 
  price: 
  ():
  # 1. Define the LLM extraction strategy
  llm_strategy = LLMExtractionStrategy(
    provider=,      
    api_token=os.getenv(),
    schema=Product.schema_json(),      
    extraction_type=,
    instruction="Extract all product objects with 'name' and 'price' from the content.",
    chunk_token_threshold=,
    overlap_rate=,
    apply_chunking=,
    input_format=,  
    extra_args={: , : }
  )
  # 2. Build the crawler config
  crawl_config = CrawlerRunConfig(
    extraction_strategy=llm_strategy,
    cache_mode=CacheMode.BYPASS
  )
  # 3. Create a browser config if needed
  browser_cfg = BrowserConfig(headless=)
    AsyncWebCrawler(config=browser_cfg)  crawler:
    # 4. Let's say we want to crawl a single page
    result =  crawler.arun(
      url=,
      config=crawl_config
    )
     result.success:
      # 5. The extracted content is presumably JSON
      data = json.loads(result.extracted_content)
      (, data)
      # 6. Show usage stats
      llm_strategy.show_usage() 
    :
      (, result.error_message)
 __name__ == :
  asyncio.run(main())

```

If your page is large, you might exceed your LLM’s context window. sets the approximate max tokens per chunk. The library calculates word→token ratio using (often ~0.75 by default). If chunking is enabled (), the text is split into segments.
To keep context continuous across chunks, we can overlap them. E.g., means each subsequent chunk includes 10% of the previous chunk’s text. This is helpful if your needed info might straddle chunk boundaries.
By chunking, you can potentially process multiple chunks in parallel (depending on your concurrency settings and the LLM provider). This reduces total time if the site is huge or has many sections.
By default, uses , meaning the is fed to the LLM. You can change to:
  * : The cleaned HTML or raw HTML (depending on your crawler config) goes into the LLM. 
  * : If you used, for instance, , the “fit” version of the markdown is used. This can drastically reduce tokens if you trust the filter. 
  * : Standard markdown output from the crawler’s .


This setting is crucial: if the LLM instructions rely on HTML tags, pick . If you prefer a text-based approach, pick .
```
LLMExtractionStrategy(
  
  input_format=, # Instead of "markdown" or "fit_markdown"
)

```

## 8. Token Usage & Show Usage
To keep track of tokens and cost, each chunk is processed with an LLM call. We record usage in:
  * (list): token usage per chunk or call. 
  * : sum of all chunk calls. 
  * : prints a usage report (if the provider returns usage data).


```
llm_strategy = LLMExtractionStrategy(...)

llm_strategy.show_usage()
# e.g. “Total usage: 1241 tokens across 2 chunk calls”

```

If your model provider doesn’t return usage info, these fields might be partial or empty.
## 9. Example: Building a Knowledge Graph
Below is a snippet combining with a Pydantic schema for a knowledge graph. Notice how we pass an telling the model what to parse.
```
 os
 json
 asyncio
 typing  
 pydantic  BaseModel, Field
 crawl4ai  AsyncWebCrawler, BrowserConfig, CrawlerRunConfig, CacheMode
 crawl4ai.extraction_strategy  LLMExtractionStrategy
 ():
  name: 
  description: 
 ():
  entity1: Entity
  entity2: Entity
  description: 
  relation_type: 
 ():
  entities: [Entity]
  relationships: [Relationship]
  ():
  
  llm_strat = LLMExtractionStrategy(
    provider=,
    api_token=os.getenv(),
    schema=KnowledgeGraph.schema_json(),
    extraction_type=,
    instruction="Extract entities and relationships from the content. Return valid JSON.",
    chunk_token_threshold=,
    apply_chunking=,
    input_format=,
    extra_args={: , : }
  )
  crawl_config = CrawlerRunConfig(
    extraction_strategy=llm_strat,
    cache_mode=CacheMode.BYPASS
  )
    AsyncWebCrawler(config=BrowserConfig(headless=))  crawler:
    
    url = 
    result =  crawler.arun(url=url, config=crawl_config)
     result.success:
       (, , encoding=)  f:
        f.write(result.extracted_content)
      llm_strat.show_usage()
    :
      (, result.error_message)
 __name__ == :
  asyncio.run(main())

```

  * ensures we get JSON fitting our . 
  * means we feed HTML to the model. 
  * guides the model to output a structured knowledge graph. 


## 10. Best Practices & Caveats
1. : LLM calls can be slow or expensive. Consider chunking or smaller coverage if you only need partial data. 2. : If your page + instruction exceed the context window, chunking is essential. 3. : Well-crafted instructions can drastically improve output reliability. 4. : extraction tries to parse the model output as JSON. If the model returns invalid JSON, partial extraction might happen, or you might get an error. 5. : The library can process multiple chunks in parallel, but you must watch out for rate limits on certain providers. 6. : Sometimes, an LLM might omit fields or produce extraneous text. You may want to post-validate with Pydantic or do additional cleanup.
in Crawl4AI is , letting you choose from hundreds of models via LightLLM. It’s perfect for tasks or generating advanced structures like knowledge graphs. However, it’s and potentially costlier than schema-based approaches. Keep these tips in mind:
  * Use to pick which form (markdown, HTML, fit_markdown) the LLM sees. 
  * Tweak , , and to handle large content efficiently. 


If your site’s data is consistent or repetitive, consider first for speed and simplicity. But if you need an approach, offers a flexible, multi-provider solution for extracting structured JSON from any website.
1. - Try switching the (e.g., , , etc.) to see differences in speed, accuracy, or cost. - Pass different like , , and to fine-tune your results.
2. - If pages are large, tweak , , or to optimize throughput. - Check the usage logs with to keep an eye on token consumption and identify potential bottlenecks.
3. - If using , parse the LLM’s JSON with a Pydantic model for a final validation step. - Log or handle any parse errors gracefully, especially if the model occasionally returns malformed JSON.
4. - Integrate LLM extraction with for complex pre/post-processing. - Use a multi-step pipeline: crawl, filter, LLM-extract, then store or index results for further analysis.
That’s it for —now you can harness AI to parse, classify, or reorganize data on the web. Happy crawling!
